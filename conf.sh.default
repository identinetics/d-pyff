#!/usr/bin/env bash

main() {
    SCRIPTDIR=$(cd $(dirname $BASH_SOURCE[0]) && pwd)
    source $SCRIPTDIR/dscripts/conf_lib.sh  $@         # load library functions
    configlib_version=2  # compatible version of conf_lib.sh
    check_version $configlib_version
    # do_not_build $@ # uncomment this line to pull/load image
    init_sudo
    _set_volume_root
    _set_image_and_container_name
    #_set_image_signature_args
    _set_users
    _set_buildargs
    _set_run_args
    #enable_pkcs11
    #set_enable_sshd     # usually used only for debugging - requires installed sshd in image
}


_set_volume_root() {
    # container volumes mounted to host paths, or symlinks to docker volumes
    DOCKERVOL_SHORT='./dv'
    DOCKERLOG_SHORT='./dl'
    mkdir -p $DOCKERVOL_SHORT $DOCKERLOG_SHORT
    DOCKER_VOLUME_ROOT='/var/lib/docker/volumes'  # hard coded - check for your config if applicable!
    #export DOCKERFILE_DIR=  # set this if the Dockerfile is not in the directory containing the dscripts subproject
}


_set_image_and_container_name() {
    # imgid qualifies image, container, user and IP adddress; this is helpful for managing
    # processes on the docker host etc.
    imgid='03'  # registered default in github.com/identinetics/dscripts/templates/assigned-uids.adoc
    projshort='pyff'
    export SERVICEDESCRIPTION=MDaggregator-idpDisco
    [[ "$DOCKER_REGISTRY_USER" ]] || export DOCKER_REGISTRY_USER='local'
    export IMAGENAME="${DOCKER_REGISTRY_USER}/${projshort}"
    export CONTAINERNAME="${imgid}${projshort}"
    [[ "$DOCKER_REGISTRY" ]] || export DOCKER_REGISTRY=''  # blank for default registry
}


_set_image_signature_args() {
    export DIDI_SIGNER='rh@identinetics.com'  # PGP uid
    export GPG_SIGN_OPTIONS='--default-key 904F1906'
}


_set_users() {
    export CONTAINERUSER="$projshort${imgid}"   # group and user to run container
    export CONTAINERUID="3430${imgid}"     # gid and uid for CONTAINERUSER
    export START_AS_ROOT=      # 'True' (e.g. for apache to fall back to www user)
}


_set_buildargs() {
    export BUILDARGS="
        --build-arg USERNAME=$CONTAINERUSER
        --build-arg UID=$CONTAINERUID
    "
    export REPO_STATUS='True'  # if set: generate 'REPO_STATUS' file to be included in docker image at /opt/etc/
    export MANIFEST_SCOPE='local'  # valid values: 'global', 'local'. Extension for manifest library.
                                   # must be local for targets. Requires write access to git for 'global'.
}


_set_run_args() {
    LOGPURGEFILES='/var/log/httpd/* /var/log/shibboleth/*'
    export ENVSETTINGS="
        -e DOCKERHOSTNAME=$HOSTNAME
        -e FREQUENCY=600
        -e LANG=de
        -e LOGDIR=/var/log
        -e LOGLEVEL=INFO
        -e PIDFILE=/var/log/pyffd.pid
        -e PORT=8080
        -e PIPELINEDAEMON=/etc/pyff/mdx_discosign_swcert.fd
        -e MDSIGN_CERT=/etc/pki/sign/certs/metadata_crt.pem
        -e MDSIGN_KEY=/etc/pki/sign/private/metadata_key.pem
        -e MD_AGGREGATE=/var/md_feed/metadata.xml
        -e REPO_HOST=github.com
        -e REPO_SSHUSER=git
        -e MDFEED_REPO=rhoerbe/mdfeedTestWpvAt
        -e MDSOURCE_REPO=rhoerbe/mdsourceTestWpvAt
    "
    # Default setup: activate if USB-based PKCS11 device is available
    HSMUSBDEVICE='Aladdin Knowledge Systems Token JC'  # output of lsusb
    if [[ "$HOSTNAME" == 'kal3' && $(lsusb | grep "$HSMUSBDEVICE") ]]; then
        enable_pkcs11
        export ENVSETTINGS="$ENVSETTINGS -e PYKCS11LIB=/usr/lib64/libetvTokenEngine.so"  # enable this for Safenet eTokePro
        #export ENVSETTINGS="$ENVSETTINGS -e PYKCS11LIB=/usr/lib64/pkcs11/opensc-pkcs11.so"  # enable this for generic OpenSC card
        export ENVSETTINGS="$ENVSETTINGS -e PYKCS11PIN=Secret.1"  # configure token password
        export ENVSETTINGS="$ENVSETTINGS -e PIPELINEBATCH=/etc/pyff/md_aggregator_sign_hwcert.fd"
    elif [[ $PIPELINEBATCH ]]; then
        export ENVSETTINGS="$ENVSETTINGS -e PIPELINEBATCH=$PIPELINEBATCH"
    else
        export ENVSETTINGS="$ENVSETTINGS -e PIPELINEBATCH=/etc/pyff/md_aggregator_sign_swcert.fd"
    fi

    export STARTCMD='/scripts/start_pyffd.sh'  # unset or blank to use image default
}


create_intercontainer_network() {
    # Create a local network on the docker host. As the default docker0 bridge has dynamic
    # addresses, a custom bridge is created allowing predictable addresses.
    network='dockernet'
    set +e  # errexit off
    $sudo docker network ls | awk '{print $2}' | grep $network > /dev/null
    if (( $? == 1)); then
        $sudo docker network create --driver bridge --subnet=10.1.1.0/24 \
                  -o com.docker.network.bridge.name=br-$network $network
    fi
    export NETWORKSETTINGS="
        --net $network
        --ip 10.1.1.${imgid}
    "
}


setup_vol_mapping() {
    # Create docker volume (-> map_docker_volume) or map a host dir (-> map_host_directory)
    # In both cases create a shortcut in the shortcut directory (DOCKERVOL_SHORT, DOCKERLOG_SHORT)
    mode=$1  # create (used by run.sh)/list (used by manage.sh)
    export VOLLIST=''
    export VOLMAPPING=''
    # create container user on docker host (optional - for better process visibility with host tools)
    #create_user $CONTAINERUSER $CONTAINERUID

    # it is good practice to map each VOLUME from the Dockerfile
    map_docker_volume $mode "${CONTAINERNAME}.etc_pki_sign" '/etc/pki/sign' 'Z' $DOCKERVOL_SHORT
    map_docker_volume $mode "${CONTAINERNAME}.etc_pyff" '/etc/pyff' 'Z' $DOCKERVOL_SHORT
    map_docker_volume $mode "${CONTAINERNAME}.home_${CONTAINERUSER}_ssh" "/home/${CONTAINERUSER}/.ssh" 'Z' $DOCKERVOL_SHORT
    map_docker_volume $mode "${CONTAINERNAME}.var_log" '/var/log' 'Z' $DOCKERLOG_SHORT
    map_docker_volume $mode "${CONTAINERNAME}.var_md_feed" '/var/md_feed' 'z' $DOCKERVOL_SHORT
    map_docker_volume $mode "${CONTAINERNAME}.var_md_source" '/var/md_source' 'z' $DOCKERVOL_SHORT

    #if [[ ! $JENKINS_HOME ]]; then
    #    $sudo chown -R $CONTAINERUID:$CONTAINERUID $DOCKER_VOLUME_ROOT/$CONTAINERNAME.* 2>/dev/null || true
    #fi

    export LOGFILES="
        $DOCKERLOG_SHORT/${CONTAINERNAME}.var_log/pyffd.log
        $DOCKERLOG_SHORT/${CONTAINERNAME}.var_log/pyffd.err
        $DOCKERLOG_SHORT/${CONTAINERNAME}.var_log/pyff_mdsplit.log
    "
}


container_status() {
    $sudo docker ps | head -1
    $sudo docker ps --all | egrep $CONTAINERNAME\$
    $sudo docker exec $CONTAINERNAME /scripts/status.sh
}


logrotate() {
    find $DOCKERLOG_SHORT/${CONTAINERNAME}.var_log/ -mtime +5 -exec ls -ld --time-style long-iso {} \;
}


main $@
